<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Object-in-javascript by xiantouxu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Object-in-javascript</h1>
      <h2 class="project-tagline">this is my study in object of JavaScript</h2>
      <a href="https://github.com/xiantouxu/object-in-JavaScript" class="btn">View on GitHub</a>
      <a href="https://github.com/xiantouxu/object-in-JavaScript/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/xiantouxu/object-in-JavaScript/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="对象" class="anchor" href="#%E5%AF%B9%E8%B1%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>对象</h1>

<p>1 JavaScript对象是动态的---可以新增属性也可以删除属性，除了字符串、数字、true、false、null、undefined之外，JavaScript中的值都是对象。
用这些术语来对三类JavaScript队形和两类属性作区分：
1 内置对象（数组、函数、日期、正则表达式）
2 宿主对象（HTMLElement对象）
3 自定义对象（有运行中JavaScript代码创建的对象）
4 自有属性（直接在对象中定义的属性）
5 继承属性（在对象的原型对象中定义的属性）
2 对象直接量是一个表达式，这个表达式的每次运算都创建病初始化一个新的的对象。每次计算对象直接量的时候，也都会计算他的每个属性的值。
3 所有通过队形直接量创建的对象都具有同一个原型对象，病可以通过JavaScript代码Object.prototype获得对原型对象的引用。通过关键字new和构造函数调用创建对象的原型就是构造函数的prototype属性的值。
4 没有原型的对象为数不多，Object.prototype就是其中之一。
5 Object.create()是一个静态函数，而不是提供给某个对象调用的方法。可以通过传入null来创建一个没有原型的新对象，此对象不会继承任何东西，甚至基础方法toString()；可以通过传入Object.prototype来创建一个普通的对象。
6 方括号内的表达式必须返回字符串或者一个可以转换为字符串的值。
7 关联数组。又称为散列、映射或字典。
8 在JavaScript中只有在查询属性时才能体会到继承的存在，而设置则和继承无关，这是JavaScript的一个重要特性，该特性让程序员可以有选择地覆盖继承的属性。
9 属性不存在，访问不会报错；对象不存在，查询此对象上的属性访问则会报错。</p>

<h3>
<a id="10-在下列情景下给对象o设置属性p时会失败" class="anchor" href="#10-%E5%9C%A8%E4%B8%8B%E5%88%97%E6%83%85%E6%99%AF%E4%B8%8B%E7%BB%99%E5%AF%B9%E8%B1%A1o%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7p%E6%97%B6%E4%BC%9A%E5%A4%B1%E8%B4%A5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>10 在下列情景下给对象O设置属性P时会失败：</h3>

<ul>
<li>O中的P是只读的</li>
<li>O中的属性P时继承属性，且是只读的</li>
<li>O中不存在自有属性P</li>
</ul>

<h3>
<a id="11-删除属性" class="anchor" href="#11-%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>11 删除属性：</h3>

<ul>
<li>Delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性。</li>
<li>Delete运算符只能删除自有属性不能删除继承属性；</li>
<li>Delete不能删除那些可配置为false的属性</li>
<li>Delete不能删除不可配置的全局变量（var x = 1; delete this.x;）但是可以（this.x = 1;delete x;可以删除）</li>
</ul>

<h3>
<a id="12-检测属性" class="anchor" href="#12-%E6%A3%80%E6%B5%8B%E5%B1%9E%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>12 检测属性：</h3>

<p>可以通过in运算符、hasOwnPreperty()和propertyIsEnumerable()方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。
In可以检测出自有属性和继承属性
hasOwnProperty()检测给定的名字是否是对象的自有属性
propertyIsEnumerable()是hasOwnProperty()的增强版，检测到时自有属性且属性是可枚举性为true才会返回true。</p>

<h3>
<a id="13-枚举属性" class="anchor" href="#13-%E6%9E%9A%E4%B8%BE%E5%B1%9E%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>13 枚举属性</h3>

<p>  对象继承的内置方法不可枚举，但在代码中给对象添加的属性都是可枚举的</p>

<h3>
<a id="14-属性getter和setter" class="anchor" href="#14-%E5%B1%9E%E6%80%A7getter%E5%92%8Csetter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>14 属性getter和setter</h3>

<p>  由getter和setter定义的属性称做“存储器属性”，它不同于“数据属性”，存储器属性不具有可写性。</p>

<h3>
<a id="15-属性的特性" class="anchor" href="#15-%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>15 属性的特性：</h3>

<ul>
<li>  Object.getOwnPropertyDescriptor()只能得到自有属性的描述符。要获得继承属性的特性，需要遍历原型链用Object.getPrototypeOf();
+　  要设置属性的特性，或者让新建属性就要某种特性，则需要调用Object.definePeoperty(),传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象。如果要同时修改或创建多个属性，则需要使用Object.defineProperties().</li>
<li>  使用extend()函数，这个函数把一个对象的属性复制到另一个对象中。只是简单复制属性名和值，并没有复制属性的特性，而且也没有复制存取器属性的getter和setter方法只是将它们简单地转换为静态的数据属性。</li>
</ul>

<h3>
<a id="16-原型属性" class="anchor" href="#16-%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>16 原型属性</h3>

<p>要检测一个对象是否是另一个对象的原型，用isPrototypeOf()方法。</p>

<h3>
<a id="17-序列化对象" class="anchor" href="#17-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>17 序列化对象</h3>

<p>是指将对象的状态转换为字符串，也可将字符串还原为对象
JSON.stringify(o); //将对象序列化
JSON.parse(s); //深拷贝
JSON支持对象、数组、字符串、无穷大数字、true、false、null，并且它们可以序列化和还原。函数、RegExp、Error对象和undefined值不能序列化和还原。</p>

<h3>
<a id="18-对象方法" class="anchor" href="#18-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>18 对象方法</h3>

<p>toString();
toLocalString();
toJSON();
valueOf();</p>

<h1>
<a id="第6章面向对象的程序设计" class="anchor" href="#%E7%AC%AC6%E7%AB%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第6章面向对象的程序设计</h1>

<h2>
<a id="61-理解对象" class="anchor" href="#61-%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.1 理解对象</h2>

<h3>
<a id="611-属性类型" class="anchor" href="#611-%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.1.1 属性类型</h3>

<ul>
<li>数据属性

<ul>
<li>Configurable:表示能否通过delete删除属性从而重新定义属性。</li>
<li>Enumerable:笔试能否通过for-in循环返回属性。</li>
<li>Writable: 表示能否修改属性的值。</li>
<li>Value: 包含这个属性的数据值。</li>
</ul>
</li>
</ul>

<p>      要修改属性的默认的特性，必须使用Object.defineProperty（）方法。例如：<br>Object.defineProperty(person,"name",{ writable:false,value:"Nicholas"}
  可以多次调用Object.defineProperty()方法修改同一个属性，但在吧configurable特性设置为false之后就会有限制了。</p>

<ul>
<li>
<p>访问器属性</p>

<ul>
<li>Configurable:表示能否通过delete输出属性从而重新定义属性</li>
<li>Enumerable:表示能否通过for-in循环返回属性。</li>
<li>Get：在读取属性时调用的函数。</li>
<li>Set：在写入属性是调用的函数。</li>
</ul>

<p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。使用Object.getOwnPropertyDescriptor()方法可以取得给定属性的描述符。</p>

<h2>
<a id="62-创建对象" class="anchor" href="#62-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.2 创建对象</h2>

<h3>
<a id="621-工厂模式" class="anchor" href="#621-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.2.1 工厂模式</h3>

<p>这种模式抽象了创建具体对象的过程。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>

<pre><code>function createPerson(name,age,job){
    var o = new Object();
    o.name = name,
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o;
}
var person1 = createPerson("Nicholas",29,"Software Engineer");
var person2 = createPerson("Grag",27,"Doctor"）;
</code></pre>

<h3>
<a id="622构造函数模式" class="anchor" href="#622%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.2.2构造函数模式</h3>

<p>function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    };
}
var person1 = new Person("Nicholas",29,"Software Engineer");
var person2 = new Person('Garg",17,"Doctor");
创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。使用构造函数的主要问题就是每个方法都要在每个实例上重新创建一遍。</p>

<h3>
<a id="623-原型模式" class="anchor" href="#623-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.2.3 原型模式</h3>

<p>我们常见的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共性的属性和方法。</p>

<p>function Person(){
}
Person.prototype.name = "Nichoals";
Person.prototype.age = 29;
Person.prototype.job = "Doctor";
Person.sayName = function(){
    alert(this.name);
};
var person1 = new Person();
person1.sayName();
var person2 = new Person();
person2.sayName();
1 理解原型属性
      在此，我们将sayName（）方法和所有属性直接添加到了Person的prototype属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法，但与构造函数模式不同的是，新对象的这些属性和方法都是有所有实例共享的。
  每当代码读取某个对象的某个属性时， 都会执行一次搜索，目标是具有给定名字的属性。搜索首先冲对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值。如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。这正是对象实例共享原型所保存的属性和方法的基本原理。实例中的同名属性会覆盖原型中的同名属性。
  使用hasOwnProperty()方法可以检测一个属性是存在于 <strong>实例</strong> 中，还是存在于原型中。
2 原型与in操作符
有两种方式使用in操作符：</p>

<ul>
<li>单独使用：in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</li>
<li>
<p>在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。
<strong>要取得对象上所有可枚举的实例属性，可以使用Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</strong>
<em>如果你想得到所有实例属性，无论它是否可枚举，到可以使用<br>Object.getOwnPropertyNames()方法。</em></p>

<p>var keys = Object.getOwnPropertyNames(Person.prototype);
alert(keys);//"constructor,name,age,job,sayName"
3 更简单的原型方法</p>
</li>
</ul>

<p>function Person(){
}
Person.prototype = {
    name:"Nicholas",
    age:28,
    job:"Software Engineer",
    sayName:function(){
        alert(this.name);
    }
};
6 原型对象的问题
  首先它忽略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题，原型模式的最大问题就是由其共享的本性所导致的。这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，然而对于包含引用类型值的属性来说，问题就比较突出了。</p>

<p>function Person(){
}
Person.prototype = {
    name:"Nicholas",
    age:28,
    job:"Software Engineer",
    friends :["Shelby","Court"],
    sayName:function(){
        alert(this.name);
    }
};
var person1 = new Person();
var person2 = new Person();
person1.friends.push("Van");
alert(person1.friends);
alert(person2.friends);
alert(person1.friends === person2.friends);//true</p>

<h3>
<a id="624-组合使用构造函数模式和原型模式" class="anchor" href="#624-%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.2.4 组合使用构造函数模式和原型模式</h3>

<p>  使用构造函数模式定义实例属性，原型模式用于定义方法和共享的属性。结果就是，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。此外，这种混成模式还支持向构造函数传递参数；</p>

<p>function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ["Shelby","Court"];
}
Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
}
var person1 = new Person("Nicholas",29,"Software Engineer");
var person2 = new Person("Greg",27,"Doctor");
person1.friends.push("Van");
alert(person1.friends); //"Shelby,Count,Van"
alert(person2.friends); //"Shelby,Count"
alert(person1.friends === person2.friends); //true
alert(person1.sayName === person2.sayName); //false</p>

<h3>
<a id="625-动态原型模式" class="anchor" href="#625-%E5%8A%A8%E6%80%81%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6.2.5 动态原型模式</h3>

<p>把所有信息都封装在构造函数中，而通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。</p>

<p>function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    //方法
    if(typeof this.sayName != "function"){
        Person.prototype.sayName = function(){
            alert(this.name);
        };
    }
}
var friend = new Person("Nicholas"29,"Software Engineer");
friend.sayName();</p>
</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/xiantouxu/object-in-JavaScript">Object-in-javascript</a> is maintained by <a href="https://github.com/xiantouxu">xiantouxu</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
